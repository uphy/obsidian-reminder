import type { Reminder, Reminders } from 'model/reminder';
import type { DateTime, Time } from 'model/time';

export enum ReminderChangeType {
    ADD,
    REMOVE,
}

export enum ReminderStatus {
    TODO,
    DONE,
    UNKNOWN,
}

export type SnapshotReminder = {
    // Our generated ID
    id: string;
    // ID of the calendar event. (generated by the sync destination service)
    // This will be used for event deletion.
    eventId?: string;
    title: string;
    time: DateTime;
    status: ReminderStatus;
};

export type ReminderChange = {
    id: string;
    eventId?: string;
    changeType: ReminderChangeType;
    reminder?: Reminder;
    status: ReminderStatus;
};

export interface ReminderEditor {
    markAsDone(reminder: Reminder): Promise<void>;
}

export abstract class ReminderSynchronizer {
    async synchronizeReminders(
        reminders: Reminders,
        defaultTime: Time,
        editor: ReminderEditor,
        force: boolean,
    ): Promise<void> {
        console.debug('Synchronize reminders: synchronizer=%s, force=%s', this.name, force);
        const snapshot = await this.snapshot(force);
        const diff = this.diff(snapshot, reminders, defaultTime, editor);
        await this.applyChanges(diff, defaultTime);
    }

    private diff(
        currentReminders: Array<SnapshotReminder>,
        newReminders: Reminders,
        defaultTime: Time,
        editor: ReminderEditor,
    ): Array<ReminderChange> {
        const diff: Array<ReminderChange> = [];

        const idToCurrentReminders: Map<string, SnapshotReminder> = new Map();
        currentReminders.forEach((currentReminder) => {
            if (idToCurrentReminders.has(currentReminder.id)) {
                // delete duplicate
                diff.push({
                    id: currentReminder.id,
                    eventId: currentReminder.eventId,
                    changeType: ReminderChangeType.REMOVE,
                    status: currentReminder.status,
                });
            }
            idToCurrentReminders.set(currentReminder.id, currentReminder);
        });

        newReminders.reminders.forEach((newReminder) => {
            const id = this.generateId(newReminder);
            const currentReminder = idToCurrentReminders.get(id);

            // Add
            if (currentReminder == null) {
                diff.push({
                    id,
                    changeType: ReminderChangeType.ADD,
                    reminder: newReminder,
                    status: ReminderStatus.TODO,
                });
                idToCurrentReminders.delete(id);
                return;
            }

            // Not changed
            if (currentReminder.status === ReminderStatus.DONE) {
                editor.markAsDone(newReminder);
            }
            idToCurrentReminders.delete(id);
        });

        // Remove
        idToCurrentReminders.forEach((currentReminder) => {
            diff.push({
                id: currentReminder.id,
                eventId: currentReminder.eventId,
                changeType: ReminderChangeType.REMOVE,
                status: currentReminder.status,
            });
        });

        return diff;
    }

    private generateId(reminder: Reminder) {
        return this.cyrb53(`${reminder.file}/${reminder.time.toString()}/${reminder.title}`);
    }

    private cyrb53(str: string, seed = 0): string {
        let h1 = 0xdeadbeef ^ seed,
            h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
        h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
        return (h2 >>> 0).toString(16).padStart(8, '0') + (h1 >>> 0).toString(16).padStart(8, '0');
    }

    abstract setupReady(): boolean;

    abstract snapshot(force: boolean): Promise<Array<SnapshotReminder>>;

    // abstract applyChanges(changes: Array<ReminderChange>, defaultTime: Time): Promise<void>;
    async applyChanges(changes: Array<ReminderChange>, defaultTime: Time): Promise<void> {
        for (const change of changes) {
            switch (change.changeType) {
                case ReminderChangeType.ADD:
                    console.debug(
                        'Add reminder to external service: synchronizer=%s, id=%s, reminder=%o, defaultTime=%s',
                        this.name,
                        change.id,
                        change.reminder!,
                        defaultTime,
                    );
                    change.eventId = await this.add(change.id, change.reminder!, defaultTime);
                    break;
                case ReminderChangeType.REMOVE:
                    console.debug(
                        'Remove reminder from external service: synchronizer=%s, externalId=%s',
                        this.name,
                        change.eventId!,
                    );
                    await this.remove(change.eventId!);
                    break;
            }
        }
    }

    /**
     * Add reminder to external service.
     *
     * @param id reminder's internal id
     * @param reminder reminder
     * @param defaultTime
     * @return added entity's external id
     */
    abstract add(id: string, reminder: Reminder, defaultTime: Time): Promise<string>;
    /**
     * Remove reminder from external service.
     *
     * @param externalId external service's id
     */
    abstract remove(externalId: string): Promise<void>;

    abstract get name(): string;
}

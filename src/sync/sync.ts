import type { Reminder, Reminders } from 'model/reminder';
import type { DateTime, Time } from 'model/time';

export class ReminderSync {
    private synchronizers: Array<ReminderSynchronizer> = [];
    private valid: boolean = false;

    addSynchronizer(s: ReminderSynchronizer) {
        this.synchronizers.push(new CachingReminderSynchronizer(s, /* 1 hour */ 60 * 60 * 1000));
    }

    invalidate() {
        this.valid = false;
    }

    async synchronizeReminders(reminders: Reminders, defaultTime: Time, force = false): Promise<void> {
        if (!force && this.valid) {
            // no need to sync
            return;
        }

        await Promise.all(
            this.synchronizers.map(async (s) => {
                if (!s.setupReady()) {
                    return;
                }
                try {
                    await s.synchronizeReminders(reminders, defaultTime);
                } catch (ex) {
                    console.error('Synchronization error: synchronizer=%s', s, ex);
                }
            }),
        );
        this.valid = true;
    }
}

export enum ReminderChangeType {
    ADD,
    REMOVE,
}

export type SnapshotReminder = {
    // Our generated ID
    id: string;
    // ID of the calendar event. (generated by the sync destination service)
    // This will be used for event deletion.
    eventId?: string;
    title: string;
    time: DateTime;
};

export type ReminderChange = {
    id: string;
    eventId?: string;
    changeType: ReminderChangeType;
    reminder?: Reminder;
};

export abstract class ReminderSynchronizer {
    async synchronizeReminders(reminders: Reminders, defaultTime: Time): Promise<void> {
        const snapshot = await this.snapshot();
        const diff = this.diff(snapshot, reminders, defaultTime);
        await this.applyChanges(diff, defaultTime);
    }

    private diff(
        currentReminders: Array<SnapshotReminder>,
        newReminders: Reminders,
        defaultTime: Time,
    ): Array<ReminderChange> {
        const diff: Array<ReminderChange> = [];

        const idToCurrentReminders: Map<string, SnapshotReminder> = new Map();
        currentReminders.forEach((currentReminder) => {
            idToCurrentReminders.set(currentReminder.id, currentReminder);
        });

        newReminders.reminders.forEach((newReminder) => {
            const id = this.generateId(newReminder);
            const currentReminder = idToCurrentReminders.get(id);

            // Add
            if (currentReminder == null) {
                diff.push({ id, changeType: ReminderChangeType.ADD, reminder: newReminder });
                idToCurrentReminders.delete(id);
                return;
            }

            // Not changed
            idToCurrentReminders.delete(id);
        });

        // Remove
        idToCurrentReminders.forEach((currentReminder) => {
            diff.push({
                id: currentReminder.id,
                eventId: currentReminder.eventId,
                changeType: ReminderChangeType.REMOVE,
            });
        });

        return diff;
    }

    private generateId(reminder: Reminder) {
        return this.cyrb53(`${reminder.file}/${reminder.time.toString()}/${reminder.title}`);
    }

    private cyrb53(str: string, seed = 0): string {
        let h1 = 0xdeadbeef ^ seed,
            h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
        h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
        return (h2 >>> 0).toString(16).padStart(8, '0') + (h1 >>> 0).toString(16).padStart(8, '0');
    }

    abstract setupReady(): boolean;

    abstract snapshot(): Promise<Array<SnapshotReminder>>;

    abstract applyChanges(changes: Array<ReminderChange>, defaultTime: Time): Promise<void>;
}

function currentTimeInMillis() {
    return new Date().getTime();
}

class SnapshotCache {
    private eventIdToReminder: Map<string, SnapshotReminder> = new Map();

    constructor(private cache: Array<SnapshotReminder>, private expiresAt: number) {
        cache.forEach((r) => {
            if (r.eventId != null) {
                this.eventIdToReminder.set(r.eventId, r);
            }
        });
    }

    get() {
        return this.cache;
    }

    add(r: SnapshotReminder) {
        this.cache.push(r);
        if (r.eventId != null) {
            this.eventIdToReminder.set(r.eventId, r);
        }
    }

    remove(eventId: string) {
        this.eventIdToReminder.delete(eventId);
        this.cache = this.cache.filter((r) => eventId !== r.eventId);
    }

    isExpired() {
        return currentTimeInMillis() > this.expiresAt;
    }
}

/**
 * An ReminderSynchronizer implementation which uses cache for snapshot() method.
 */
class CachingReminderSynchronizer extends ReminderSynchronizer {
    private cache?: SnapshotCache;

    constructor(private reminderSynchronizer: ReminderSynchronizer, private ttlMillis: number) {
        super();
    }

    setupReady(): boolean {
        return this.reminderSynchronizer.setupReady();
    }

    async snapshot(): Promise<SnapshotReminder[]> {
        const cache = this.getCache();
        if (cache != null) {
            return cache.get();
        }

        const snapshot = await this.reminderSynchronizer.snapshot();
        this.updateCache(snapshot);
        return snapshot;
    }

    private updateCache(snapshot: Array<SnapshotReminder>) {
        this.cache = new SnapshotCache(snapshot, currentTimeInMillis() + this.ttlMillis);
    }

    private getCache() {
        const c = this.cache;
        if (c != null && !c.isExpired()) {
            return c;
        }
        return undefined;
    }

    async applyChanges(changes: ReminderChange[], defaultTime: Time): Promise<void> {
        // Update actual service first for getting newly added event's 'eventId'
        await this.reminderSynchronizer.applyChanges(changes, defaultTime);

        // After updating 'eventId', we have to also apply changes to cache.
        const cache = this.getCache();
        if (cache == null) {
            return;
        }
        changes.forEach((change) => {
            switch (change.changeType) {
                case ReminderChangeType.ADD:
                    if (change.reminder != null) {
                        cache.add({
                            id: change.id,
                            eventId: change.eventId,
                            title: change.reminder.title,
                            time: change.reminder.time,
                        });
                    }
                    break;
                case ReminderChangeType.REMOVE:
                    if (change.eventId != null) {
                        cache.remove(change.eventId);
                    }
                    break;
            }
        });
    }
}
